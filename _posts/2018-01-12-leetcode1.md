---
layout: post
title: leetcode1--two sum
date: 2018-01-12
description: "leetcode"
tag: leetcode
---   

### 题目

题目如下


```

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

```


### 解答

这个最容易想到的就是暴力search,直接两个for判断就可以了，但是这样行是行，但是效率不高，这个里面有个很强的假设，即刚好有一个解，

高效的方式是o(n)就可以做到，我现在思维上有个缺点，总是会把o(n)当成是遍历一次，其实o(n)可以遍历好几次，这种把多层for拆开来做的基本上都是采用的这种想法，即多次遍历，注意不是多重遍历。

这样这个题可能先遍历一次，以值为key,以index作为value来建立一个字典，
然后再遍历一次，对于nums[i]这个数，来看'target-nums[i]'有没有在上一步的字典中有，注意这时候第二个index应该是大于第一个才可以，

代码如下

```
class Solution(object):
    
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        dic = dict(zip(nums, range(len(nums))))
        for i in range(len(nums)):
            j = dic.get(target-nums[i], -1)
            if j >-1 and i < j:
                return [i,j]
    
```


用c++的话，需要用到`unordered_map`。

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        //申请一个对象
        unordered_map<int, int> m;
        vector<int> res;
        for(int i=0;i<nums.size();i++){
            m[nums[i]] = i;
        }
        for(int i=0;i<nums.size();i++){
            int t=target-nums[i];
            if(m.count(t) && m[t] !=i){
                res.push_back(i);
                res.push_back(m[t]);
                break;
            }
        }
        
        return res;
    }
};

```

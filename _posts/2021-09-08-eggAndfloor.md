---
layout: post
title: 两个鸡蛋，100层楼
date: 2021-09-08
categories: [数学]
tags: 数学
---


#### 问题描述
```
问题描述：
    有一栋楼共100层，一个鸡蛋从第N层及以上的楼层落下来会摔破， 在第N层以下的楼层落下不会摔破。给你2个鸡蛋，设计方案找出N，并且保证在最坏情况下， 最小化鸡蛋下落的次数。
```
#### 循序渐进的思路

**<font color=blue>1. 二分</font>**
```
最坏情况，在50层试一下，破了。
只能从第一层往上试，最坏情况是试到了49层，一共尝试了49+1=50次。很显然不行
```

**<font color=blue>2. 均匀分段</font>**
```
假设每隔k层，测试一次，则一共分为100/k 段，最差情况，在倒数第二个点第一次鸡蛋破了，
此时情况最坏需要尝试 100/k - 1 + k - 1 = 100/k + k - 2 次。
k==10的时候，取得最坏情况下18次尝试。
```
<font color=red>看起来是个不错的方法，但是它存在一个很致命的问题。就是，如果第一次尝试，鸡蛋不破，此时问题变成90层楼，2个鸡蛋尝试的问题。变得复杂难解</font>


**<font color=blue>3. 不均匀分段</font>**  **<font color=green>最优解</font>**
```
换个思路来想，我们假设最坏尝试x次
1. 如果第一次测试就破了，第二个蛋就要从初始层往上一直试到到x-1层，此时刚好最坏尝试了1 + x - 1 次。也即第一个测试点设在了x层。
2. 如果第一次测试没有破，那么相当于还有x-1次机会。如果第二次破了，此时还有 x-2次机会。我们会发现第二个点与第一个点相距x-1。
3. 如果第一次没破，第二次又没破，相当于还有x-2次机会，此时第三个点与第二个点相距x-2。依次类推：
此时会发现 我们最坏尝试x次，可以测试的最大楼层是 x + (x-1) + (x-2) + (x-3) + ... + 2 + 1 >=100
x(1+x)/2 >= 100
可以求解 x = 14
分段的楼层分别是 14, 27, 39, 50, 60, 69, 77, 84, 90, 95, 99, 100
```

**<font color=blue> 4. 问题进阶: e个鸡蛋，M层楼层, 此时求解最少的最坏次数N</font>**
```
f[d][e]表示d 层楼，e个鸡蛋时，最坏情况下的测试次数，则：

f[d][e]=min{max(f[d-i][e]+1，f[i-1][e-1]+1)}，i=1,2,...,d;

f[k][1]=k，0<=k<=d，f[0][0...e]=0;

int min_testnumber(int d, int e)  
{  
        int **f=new int *[d+1];  
        int i,j,k;  
        for(i=0;i<=d;i++)  
            f[i]=new int[e+1];  
        for(i=0;i<=d;i++)  
            f[i][1]=i;  
        for(i=0;i<=e;i++)  
            f[0][e]=0;  
        for(i=1;i<=e;i++)  
        {  
            for(j=1;j<=d;j++)  
            {  
                int tmp;  
                int min_test=0x7FFFFFFF;  
                for(k=1;k<=j;k++)  
                {  
                    tmp=f[j-k][i]+1>f[k-1][i-1]+1?f[j-k][i]+1:f[k-1][i-1]+1;  
                    if(tmp>min_test)  
                        min_test=tmp;  
                }  
                f[j][i]=min_test;  
            }  
       }  
       return f[d][e];  
}
```

---
layout: post
title: openpose-测试代码
date: 2018-10-20 11：55 +0800
categories: [代码详解]
tags: 代码详解
---
<!--more-->
### 对应的是test_pose.py代码中的内容
我觉得整个代码可能最难写的部分就是测试部分了，也是我读完论文急于想知道具体是怎么做的部分，
先recall一下整个的流程，前面的网络用来提特征，提完特征之后，在每个channel上面得到了所有可能的峰值点，可能不只一个，只要通过某一阈值的基本上都要了，
这相当于有了18个集合，每个集合里面存的都是网络的输出的可能的关键点的位置。
然后下面的一步就是这些点如何连接起来的问题，因为每个part现在都有可能是多个峰值点，那么如何选择的呢。
以A-part和B-part为例，假设对应着上面提到的集合的前面两个，在gt中这两个部分是一个连接关系，那么现在要在这里面找到这条边。
因数A-part和B-part里面都可能有多个点，所以要建立各个边之间的一个关系大小。
假设各自有m,n个点，那么这时候会有mn个关系，这个关系的计算是按照paper里面做线积分的办法来做的，这
mn个关系记录好之后，对这mn个做个排序，选择分最高的那个作为AB之间的连接。从这里可以看出来确实是贪心算法。文章中也说是贪心算法。
这样每一个part都弄完之后，那么最终的关系图也就出来了。
当然里面会有许多的细节，个人觉得这个实现还是非常有技术的，和之前在看coco评测的map的时候感觉差不多，就感觉这个实现出来挺不容易的。非常值得学一学里面的想法和一些技巧。

### 细节
不过这里面在取top1的时候，用的并不是paper里面的原想法，而是算了线积分之后又加了两头的heatmap上的分数。

其实预测的heatmap是要加上图像本身的像素的（这里面经过了normalize,normalize也比较合理，因为预测的是经过sigmoid的概率，是在(0,1)之间），之前读paper的时候误以为预测的就只是概率值，不加上其他的任何处理呢。

代码刚开始还用了4个scale分别是0.5，1，1.5，2.0,然后接着就是产生heatmap_avg, paf_vag，不太明白为什么要用多个scale。






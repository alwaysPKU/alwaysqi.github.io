---
layout: post
title: leetcode661
date: 2018-01-01
description: "leetcode"
tag: leetcode
---   

这个题目是'image smother', 意思是给一个二维的数组，其中每个点的值都是其周围的值和其自己的一个平均，然后输出smooth后的数组，
其实这个问题可以理解为就是一个卷积核，如果用numpy的话会比较容易，但是现在是两个list的形式，也是可以做的。其中每个像素值是0到255.

### python

```
def fun(M):
    if len(M)==0:
        return
    m = len(M)
    n = len(M[0])
            
    out = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(m):
        for j in range(n):
            direction = [(i-1,j-1), (i-1,j),(i-1,j+1), (i,j-1),(i,j),(i,j+1), (i+1,j-1),(i+1,j), (i+1,j+1)]
            num = 0
            summ = 0
            for x in direction:
                if x[0]>=0 and x[0] <= m-1 and x[1]>=0 and x[1]<= n-1:
                    num += 1
                    summ += M[x[0]][x[1]]
            
            if num>0:
                out[i][j] = summ/num
    return out
                    
```

注意上面有几处需要注意的地方，

* 不要只用M，因为M一直在变。可以另申请一个，也可以深copy一个。

* out 不要用`out=[[0]*n]*m` 的方式，这是我之前碰到的一个bug.

* 上面是自然想到的一种实现的办法，但是其实不太好，其实有几点没有注意到，0到255，这个是8个byte，这一点没有用到。


### c++

```
class Solution {
public:
    vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
        
        std::vector<std::vector<int>> result;
        for(int i=0;i<M.size();++i){
            result.emplace_back();
            result.back().reserve(M[i].size());   
            for(int j=0; j<M[i].size();++j){
                int qty=1, sum=M[i][j];
                if(0 != i){
                    sum += M[i-1][j];
                    ++qty;
                    if(0 != j){
                        sum += M[i-1][j-1];
                        ++qty;
                    }
                }
                if(M.size()-1 != i){
                    sum += M[i+1][j];
                    ++qty;
                    if(M[i].size()-1 != j){
                        sum += M[i+1][j+1];
                        ++qty;
                    }
                }
                
                if(0 != j){
                    sum += M[i][j-1];
                    ++qty;
                    if(M.size()-1 != i){
                        sum += M[i+1][j-1];
                        ++qty;
                    }
                }
                if(M[i].size()-1 != j){
                    sum += M[i][j+1];
                    ++qty;
                    if(0!=i){
                        sum += M[i-1][j+1];
                        ++qty;
                    }
                }
                result.back().push_back(sum / qty);
                
            }
            
        }
        return result;    
    }
    
};

```

如果看的更清晰一些的话，可以这样写


```
#include <iostream>
#include <vector>
std::vector<std::vector<int> > imageSmoother(std::vector<std::vector<int> >& M) {

        std::vector<std::vector<int> > result;
        for(int i=0;i<M.size();++i){
            result.emplace_back();
            result.back().reserve(M[i].size());  //为下一行yuliu空间。 
            for(int j=0; j<M[i].size();++j){
                int qty=1, sum=M[i][j];  //初始化为自已。
                // 加上其左上角的两个
                if(0 != i){
                    sum += M[i-1][j];
                    ++qty;
                    if(0 != j){
                        sum += M[i-1][j-1];
                        ++qty;
                    }
                }
                // 右下角的两个
                if(M.size()-1 != i){ 
                    sum += M[i+1][j];
                    ++qty;
                    if(M[i].size()-1 != j){ 
                        sum += M[i+1][j+1];
                        ++qty;
                    }   
                }
    
                //左下角的两个
                if(0 != j){ 
                    sum += M[i][j-1];
                    ++qty;
                    if(M.size()-1 != i){ 
                        sum += M[i+1][j-1];
                        ++qty;
                    }   
                }
                //右上角的两个。
                if(M[i].size()-1 != j){ 
                    sum += M[i][j+1];
                    ++qty;
                    if(0!=i){
                        sum += M[i-1][j+1];
                        ++qty;
                    }   
                }
                result.back().push_back(sum / qty);
                // result.back()是当前的这一行，它也是个vector,所以用push_bac.

                 
            }

        }
        return result;
}


```

然后在本地编译的时候刚开始用的是`g++`直接编译的，出了许多错，主要是 `vector<vector<int>>`在`98`的version中是需要再`>>`之间加上空格的，`11`之后就不需要了。所以编译的时候

`g++ 661.cpp -std=c++11`
就可以了。

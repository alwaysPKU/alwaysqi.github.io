---
layout: post
title: openpose-exercise-2
date: 2018-11-05
categories: [torch]
tags: torch
---
<!--more-->

上个blog 把大致的过程记录了一下，这次开始针对其中的一些细节讨论。
第一个便是数据增强。

torch里面有关于数据增强的，之前在cifar10里面就用到过，即
`import torchvision.transforms as transforms`
中的函数。
那时候只需要传入从`Image`中读出的图像即可，因为对于分类问题label不会因为图的变换而发生变化，但是现在不一样了，如果图发生了变换，那关键点和一些分割的信息，以及bbox的信息都会发生变化，还有如果做了镜像对称的话，人的关节也是要换位置的，这对于后面要把这些关节点连接起来至关重要，这些其实作者在实现的时候都注意到了，下面备注一下数据变换的操作。

### Mytransform里面的变换

这里面有

* `normalize`

* `to_tensor`

    用于把numpy 转成torch中的tensor, torch里面的transform也有这一步操作

* resize

resize 不仅要对原图进行resize还要对mask ,kpts, center, 都要进行resize,
其中center是标记的人所在的bbox的中心，这个函数比较容易实现，都是cheng上对应的ratio就可以了。
img, 和 mask可以用cv里面的函数直接resize.

* RandomResized 是个类

这个类有个static method主要是获得图的shape,以及要resize的ratio,这个ratio是随机选取的，在这里是`random.uniform(scale_min, scale_max)`, 当然也可以将其固定的某一ratio.
我不太明白为什么代码里面还有个`0.6`是做什么的，而且要注意传进来的`scale`是什么，如果记进入网络的size是`train_size`的话，这样`scale=bbox[3]/trian_size`, 而如果没有`0.6`的话，最终从这里返回用于去resize的ratio就是`random.uniform(min, max)*train_size/bbox[3]`,所以如果想要进入网络的大致是'train_size'的话，所以这一步resize的时候并没有返回一个固定的shape, 只是一个大致。

* rotate

这个操作也得使得img, mask, kpts, center都要做相应的变换，还好的是，cv里面已经有实现好的接口可以用，即要先求出rotate矩阵，这个是由`img_center`来确定的，即图的中心，然后 需要算新的w,h,这画个图就可以看出来了，是几个顶点所框定的新的范围。其中关键点的新的位置是和rotate矩阵做内积。得到。bbox中心也是的。

这里面用到了`np.ascontiguousarray(img)`查了一下，大致的意思是希望能够像c里面的数组那样连续存储这里的array,这样估计会对后面的计算提升效率。然后行随机rotate.

* crop

随机crop这个里面的细节比较多，确定crop后的图像的方法是确定其左上角，
因为有了crop的shape之后，加上左上角就可以确定右下角，进而确定整个形状。
那么确定左上角的方法是确定中心，只要找到了要crop的中心，根据要crop的大小，就可以算出左上角的位置。
说的有点别扭了，即
`find crop_center---> find leftup corner---->find crop bbox`

crop接收的参数有要输出的shape（w,h）和 `offset_left, offset_up`这即要crop的左上角的位置。即要返回的图像的(0,0)位置，所以`kpt, bbx_center` 都要减掉它们得到相对于返回图像的位置，然后 crop_img和crop_mask就要用slice的操作来得到了。

上面的左上角刚才说了，是从要crop的中心和crop_size算出来的，而要crop的中心是由center（是人的位置的bbox的center）经过随机的一个偏移得到的，注意这里面有两个center，一个是图像的center,一个是图像中的人的位置的bbox的center,别搞错了。
为什么要以人的bbox的center来做呢？
这是因为希望crop后的图像包括人，不然的话，就降低了数据量了。这是我的理解。

* hflip

这个比较好理解，注意一个公式即可
`before+after=width-1`
因为
`(before+after)/2 = (width-1)/2`即关于中轴对称，`width-1`是因为`width`并不是真正的物理上的宽，而是像素点的个数，所以中间的间隔的话是`width-1`个距离。

### 总结

看懂这里的函数一定会在其他的问题上用到，所以花了很长的时间，研究这段代码。









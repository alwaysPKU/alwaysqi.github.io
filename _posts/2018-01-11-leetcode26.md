---
layout: post
title: 再看leetcode26--Remove Duplicates from Sorted Array
date: 2018-01-11
description: "leetcode"
tag: leetcode
---   

### 题目

这个题目之前做过一次，再补充一些东西，后来走在路上又想了想这个问题，其实这个题的困难可能在于边删除的时候数组的长度在变化，而这对于后面的index就会有影响，比如它本来在第10个位置上的，但是前面的有删除的了，所以现在的第10个也变化了，后来我想，如果从后面开始处理的话就不会出现这种情况。

代码如下

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        for(int j=nums.size()-1;j>0;j--){
            
            if(nums[j]==nums[j-1]){
                nums.erase(nums.begin()+j);
            }
        }
        return nums.size();
    }
};

```

也可以用`unique`函数

这里如果只是返回最后得到的长度的话，用python里面的`return len(set(nums))`就搞定了，不过这里要求的是操作的同时，最后的nums必须就是最后的结果，虽然没有要求返回。

```

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        auto p = unique(nums.begin(), nums.end());
        nums.erase(p, nums.end());
        return nums.size();
    }
};

```


---
layout: post
title: c++中的template
date: 2018-03-01
categories: [c++]
tags: c++
---
<!--more-->

template 就像泛涵分析一样，是一个抽象相当于，所以感觉还是非常有用的，例子如下，
先是函数模板。


```
#include <iostream>
#include <string>

using namespace std;


template<typename T>
inline T const& Max(const T& a, const T& b){ 
    return a<b?b:a;
}


int main(){
    int i=39,j=20;
    cout<<Max<int>(i,j)<<endl;
    
    float f1=13.5,f2=20.7;
    cout<<Max<float>(f1,f2)<<endl;
    
    string s1="Hello", s2="world";
    cout<<Max<string>(s1,s2)<<endl;
    return 0;
}


```

可以看出来，如果想要定义一个函数，比较二者之中的最大值，一会儿整数，一会儿实数，还有的是string,那么如果写三个函数的话就太麻烦了，所以写一个模板就可以了，注意为了清晰，用的时候传入具体的typename就可以了，当然有时候它会自动进行类型检查，但是最好还是加上。


也有类的模板，这相当于把某些具有一些相同的特征的东西用一个模板全部搞定。


```
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>
#include <stdexcept>

using namespace std;

template <class T>
class Stack{
    private:
        vector<T> elems;   //元素
    
    public:
        void push(T const&);   // 入栈，后面实现
        void pop();
        T top() const;   //栈顶元素

        bool empty() const{
            return elems.empty();
        }

};


template <class T>
void Stack<T>::push(T const& elem){
    elems.push_back(elem);
}


template <class T>
void Stack<T>::pop(){
    if(elems.empty()){
        throw out_of_range("Stack<>::pop(): empty stack");
    }   
    //删除最后一个元素
    elems.pop_back();
}

template <class T>
T Stack<T>::top() const{

    if(elems.empty()){
        throw out_of_range("Stack<>::top(): empty stack");
    }   
    //返回最后一个元素的一个副本
    return elems.back();    
}

int main(){
    try{
        Stack<int> intStack;
        Stack<string> stringStack;
    
        intStack.push(7);

        cout<<intStack.top()<<endl;

        //操作string
        stringStack.push("hello");
        cout<<stringStack.top()<<std::endl;
        stringStack.pop();
    }
    catch(exception const& ex){
        cerr<<"Exceptions"<<ex.what()<<endl;
    }
    return -1;
}



```

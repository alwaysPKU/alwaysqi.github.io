---
layout: post
title: leetcode26--remove duplicates from sorted array
date: 2018-01-07
description: "leetcode"
tag: leetcode
---   

### 很容易理解，就是删除掉重复的数组，返回最终的不重复的，并返回个数。
应该O(n)就能完成

```
def remove_duplicate(nums):
    if len(nums)<2:
        return nums, len(nums)

    k = 0
    ret = range(nums[0], nums[-1]+1)
    for i, x in enumerate(ret):
        if x in nums:
            k += 1
        else:
            del(ret[i]) 
             
    return ret, k
```

上面是我看到题目之后先想到的，即先看两端的，然后知道一个范围，再看里面的具体有没有，不过不是很好，比如如果nums是`[1,100000000]`那就太亏了。

所以修改成下面的思路，可以看前后两个是否一样，如果一样就删除，不一样就继续往下看。

```
def remove_duplicate(nums):
    if len(nums)<2:
        return nums, len(nums)

    k = 1

    ret = []    
    ret[:] = nums
    
    for i in range(1, len(nums)):
        if nums[i] == nums[i-1]:
            del(ret[i])
        else:
            k += 1
        
        
    return ret, k

```


用c++的话

```
int remove_duplicates(vector<int>& nums){
    if(nums.empty()){
        return 0;
    }
    int previousNum = nums[0];
    int itr = 1;
    while(itr<=nums.size()){
        if(previousNum == nums[itr]){
            nums.erase(nums.begin()+itr);
        }else{
            previousNum = nums[itr];    //update previousNum and itr
            ++itr;
        }

    }

    return nums.size();   //but this just return nums.size()
}
```

`erase`相当于python里面的`del`


---
layout: post
title: leetcode189
date: 2018-01-03
description: "leetcode"
tag: leetcode
---   

这个题目是旋转数组，即给定一个数组，[1,2,3,4,5,6,7],如果要旋转的是1的话，就是[7,1,2,3,4,5,6].其它的类似，
思路:其实解决办法挺多的，比如可以把最后一个pop出来，然后insert到第一个位置。

```
class Solution(object):
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if k==0:
            return
        for i in range(k):
            last = nums.pop()
            nums.insert(0,last) 

```

也可以用拼接的方式

```
class Solution(object):
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if k==0:
            return
        for i in range(k):
            last = nums.pop()
            # nums.insert(0,last) 
            nums[:] = [last]+nums[:]

```

注意上面的`nums[:]`如果写成`nums`的话是错的。

也可以按下面的方式拼接

```
class Solution(object):
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if k==0:
            return
        # for i in range(k):
        #     last = nums.pop()
        #     # nums.insert(0,last) 
        #     nums[:] = [last]+nums[:]
        n = len(nums)
        k = k % n
        nums[:] = nums[n-k:] + nums[:n-k]
            

```

上面三种都可以用python来进行实验。

当然也应该注意一些特殊情况是不需要处理的，比如当k刚好是len(nums)的倍数的时候。这时候直接返回就可以了，不需要再做各种操作。所以应该把最初的改成

```
if k%(len(nums)) == 0:
    return
```
上面的办法都是因为python把一些东西都实现好了。但是如果更细致的来做呢。

下面是一个O（1）空间，O（n）复杂度的一个写法

```
void rotate(vector<int>& nums, int k){
    int now=0;   //初始化第一个的idx
    int temp1, temp2=nums[0]; //这两个分别是存储，交换前的和交换后的，temp2是个游标的东西
    for(int j=0;i=0;j<nums.size();j++){
        temp1 = temp2;// 获得当前的值
        now = (k+now)%(nums.size());   //找到它将要去的位置
        temp2 = nums[now];  //把那个位置上的值换成游标数据
        nums[now] = temp1;   
        
        //下面是更新游标，其实上面temp2=nums[now]已经更新了游标，但是还有一种情况是刚好回来的时候，比如[1,2,3,4,5,6], k=2的时候，1-->3--->5-->1，这时候需要
        //进行下一个，即把游标的值换成2就可以了。
        if(now==i){
            now = ++i;
            temp2=nums[now];
        }
    }
}

```

上面的写法也可以改成while来做，因为最多更换的次数就是len(nums)次。


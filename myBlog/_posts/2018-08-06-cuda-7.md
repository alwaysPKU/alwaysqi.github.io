---
layout: post
title: CUDA-7
date: 2018-08-07
categories: [CUDA]
tags: CUDA
---
<!--more-->

这次用cuda实现一个波纹的效果。
假设要产生的图像的像素个数是`(DIM, DIM)`,当然也可以是`(DIM1, DIM2)`.因为图像看每个channel的话是2维的任务了，所以更适合用2维线程idx来做这个。

```
    dim3 blocks(DIM/16, DIM/16);
    dim3 threads(16,16);
    kernel<<<blocks, threads>>>(,);
    
```

其中`blocks`和`threads`都是二维的变量，其中`blocks`表示在线程格中包含的并行线程块数量。变量`threads`表示在每个线程块中包含的线程数量。
那么在核函数里面需要把threadIdx和blockIdx.x map 到像素的位置上去

```
int x = threadIdx.x + blockIdx.x*blockDim.x;
int y = threadIdx.y + blockIdx.y*blockDim.y;
int offset = x+y*blockDim.x*gridDim.x;
```

上面代码可以这样理解，假设`DIM=1600`吧，那么现在就相当于用`16-16`的砖头去铺，那么应该需要`100*100`块砖头，这些砖头的标号是二维的`(blockIdx.x, blockIdx.y)`,而上面的`(x,y)`的意思就是第`(blockIdx.x, blockIdx.y)`个砖头的第`(threadIdx.x, threadIdx.y)`位置相对于整个大砖的位置。
举个例子，比如`(blockIdx.x, blockIdx.y)=(3,4)`，`threadIdx.x, threadIdx.y=(10,12)`,那么`(x,y)=(310, 412)`, 即相对于整个大图的位置，而大图是一个一维的数组啊，所以又要转一次转成在一维中的位置。所以`offset=310+412*16*100` 因为这里的图是方的，所以把y理解成是大图中的行号或者列号都是可以的，对最终的结果没有什么影响。




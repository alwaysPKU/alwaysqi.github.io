---
layout: post
title: static-define-const-incline
date: 2018-03-01
categories: [c++]
tags: c++
---
<!--more-->


### static

产生背景：

函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，但是函数在栈上分配的空间在此函数执行结束时会释放掉。这样就有一个问题，如果想将函数中此变量保存的值保存到下一次调用时，如何实现？

最容易想的是定义一个全局的变量，但是这样破坏了变量的访问范围。

解决办法：

引入static,用它来修示变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样目的就达到了，而且此变量的范围是不变的。


### define

define 是定义预编译时处理的宏，只进行简单的字符替换，没有类型的检测，

define 的好处：

比如
`#define MAX_BATCH 1000`,

这样很容易知道这个数字的意义，而且改的时候非常方便，不然后话，如果代码中有100个地方需要改的话，工程量太大了。
但是这只是简单的值替代，没有类型的检查机制，可能会导致一些错误。所以就有了const

### const

const的用法是这样的

`const int A=100;`这样有类型也有值，

const是个左结合的类型修饰符，运算是从右边。

`const int *p` 的意思`*p=100`这种操作是不能够的，即不能够通过指针取值的方式来改变这个指针所指向的值，见下面的示例。

```
#include <iostream>
#include <stdlib.h>

using namespace std;

int main(){


    int i1=30;
    int i2=40;
    const int* p= &i1;
    cout<<*p<<endl;
    
    p = &i2;
    i2 = 80; 
    //可以通过上面的方式来改变p所指向的变量的值。    
    cout<<*p<<endl;
    
    //但是不能够通过直接*p=100;来操作
    
    return 0;
}


```
这种感觉用的是比较多的，还有一种是
`int* const p`

这时候说明p不能够改，即是个常量的指针。
见下例

```
#include <iostream>
#include <stdlib.h>

using namespace std;

int main(){
    int i1=30;
    int i2=40;
    int * const p = &i1;
    //p = &i2, 这个就是错的，因为它是不能够改的。

    cout<<*p<<endl;
    //但是它指向的值是可以改的。

    i1 = 100;
    cout<<*p<<endl;








    return 0;
}


```

### inline

inline的介绍感觉cainiao上面讲的比较清晰，
